<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <script src="./src/libOpenDrive.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"></script>
    <script src="https://unpkg.com/earcut@2.2.2/dist/earcut.min.js"></script>
    <script>
        var camera, controls, scene, renderer;
        var line_group, mesh_group, probe_point, probe_line, gui;
        var mouse, raycaster, intersections;

        var odr_data = null;
        var OpenDriveMap = null;
        var ModuleOpenDrive = null;
        var bbox_to_odr_geom = new Map();
        var odr_geom_to_odr_road_id = new Map();

        var params = {
            resolution: 0.4,
            wireframe: false,
        };

        init();
        animate();

        function get_std_map_keys(std_map) {
            let keys = [];
            for (let idx = 0; idx < std_map.keys().size(); idx++)
                keys.push(std_map.keys().get(idx));
            return keys;
        }

        function get_nearest_odr_geoms(x, y, n) {
            let sorted_bboxs = new Array(...bbox_to_odr_geom.keys()).sort((a, b) => a.get_distance([x, y]) - b.get_distance([x, y]));
            let result = [];
            for (let i = 0; i < n; i++)
                result.push(bbox_to_odr_geom.get(sorted_bboxs[i]));
            return result;
        }

        function rdp(points, eps) {
            const last = points.length - 1;
            const p1 = points[0];
            const p2 = points[last];
            const x21 = p2[0] - p1[0];
            const y21 = p2[1] - p1[1];

            const [dMax, x] = points.slice(1, last)
                .map(p => Math.abs(y21 * p[0] - x21 * p[1] + p2[0] * p1[1] - p2[1] * p1[0]))
                .reduce((p, c, i) => {
                    const v = Math.max(p[0], c);
                    return [v, v === p[0] ? p[1] : i + 1];
                }, [-1, 0]);

            if (dMax > eps) {
                return [...rdp(points.slice(0, x + 1), eps), ...rdp(points.slice(x), eps).slice(1)];
            }
            return [points[0], points[last]]
        };

        function load_odr_data(xodr_file, resolution, use_wireframe) {
            libOpenDrive().then(Module => {
                ModuleOpenDrive = Module;
                fetch(xodr_file).then((res) => {
                    res.text().then((data) => {
                        Module['FS_createDataFile'](".", "data.xodr", data, true, true);
                        OpenDriveMap = new Module.OpenDriveMap("./data.xodr");
                        for (let road_id of get_std_map_keys(OpenDriveMap.roads)) {
                            const odr_road = OpenDriveMap.roads.get(road_id);

                            let ref_line_points = [];
                            for (let sample_nr = 0; sample_nr < (odr_road.length / resolution); sample_nr++)
                                ref_line_points.push(odr_road.get_refline_point(sample_nr * resolution, 0.0));
                            ref_line_points = rdp(ref_line_points, resolution);
                            const ref_line_geom = new THREE.BufferGeometry().setFromPoints(ref_line_points.map(p => new THREE.Vector3(...p)));
                            const ref_line_line = new THREE.Line(ref_line_geom, new THREE.LineBasicMaterial({ color: 0xffffff }));
                            line_group.add(ref_line_line);

                            let lane_sec_s0 = get_std_map_keys(odr_road.lane_sections);
                            lane_sec_s0.sort((a, b) => a - b);
                            for (let ls_idx = 0; ls_idx < lane_sec_s0.length; ls_idx++) {
                                const odr_lane_sec = odr_road.lane_sections.get(lane_sec_s0[ls_idx]);
                                const lane_sec_length = (ls_idx == (lane_sec_s0.length - 1)) ? odr_road.length - odr_lane_sec.s0 : lane_sec_s0[ls_idx + 1] - odr_lane_sec.s0;
                                let lane_idxs = get_std_map_keys(odr_lane_sec.lanes);

                                let road_polygon_pts = [];
                                for (let is_leftmost_lane of [true, false]) { //relative to ref line direction
                                    const odr_lane = is_leftmost_lane ? odr_lane_sec.lanes.get(Math.max(...lane_idxs)) : odr_lane_sec.lanes.get(Math.min(...lane_idxs));
                                    let lane_outer_border_pts = [];
                                    for (let sample_nr = 0; sample_nr <= (lane_sec_length / resolution); sample_nr++)
                                        lane_outer_border_pts.push(odr_lane.get_outer_border_pt(odr_lane_sec.s0 + sample_nr * resolution));
                                    lane_outer_border_pts.push(odr_lane.get_outer_border_pt(odr_lane_sec.s0 + lane_sec_length));
                                    lane_outer_border_pts = rdp(lane_outer_border_pts, resolution);
                                    if (is_leftmost_lane)
                                        lane_outer_border_pts.reverse();
                                    road_polygon_pts.push(...lane_outer_border_pts);
                                }
                                road_polygon_pts.push(road_polygon_pts[0]);

                                const road_polygon_geom = new THREE.BufferGeometry().setFromPoints(road_polygon_pts.map(p => new THREE.Vector3(...p)));
                                road_polygon_geom.setIndex(earcut(road_polygon_pts.flat(), null, 3));
                                const road_polygon_mesh = new THREE.Mesh(road_polygon_geom, new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: use_wireframe, transparent: true, opacity: 0.3 }));
                                mesh_group.add(road_polygon_mesh);
                            }
                            for (let geom_s0 of get_std_map_keys(odr_road.geometries)) {
                                const odr_geom = odr_road.geometries.get(geom_s0);
                                bbox_to_odr_geom.set(odr_geom.bounding_box, odr_geom);
                                odr_geom_to_odr_road_id.set(odr_geom, road_id);
                            }
                        }
                        scene.add(line_group);
                        scene.add(mesh_group);
                    });
                });
            });
        }

        function init() {
            load_odr_data('./data.xodr', params.resolution, params.wireframe);
            scene = new THREE.Scene();
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 100000);
            camera.position.set(0, 0, 100);
            camera.lookAt(0, 0, 0);
            camera.up.set(0, 0, 1); /* Coordinate system with Z pointing up */
            controls = new THREE.MapControls(camera, renderer.domElement);

            let helper = new THREE.GridHelper(500, 50, 0x0000ff, 0xffffff);
            helper.geometry.rotateX(Math.PI / 2);
            helper.position.y = 0;
            helper.material.opacity = 0.25;
            helper.material.transparent = true;
            scene.add(helper);

            let probe_point_geom = new THREE.SphereGeometry(0.1, 32, 32);
            probe_point = new THREE.Mesh(probe_point_geom, new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            scene.add(probe_point);

            let probe_line_geom = new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(new Float32Array(2 * 3), 3));
            probe_line = new THREE.Line(probe_line_geom, new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            scene.add(probe_line);

            raycaster = new THREE.Raycaster();
            raycaster.params.Line.threshold = 0.1;
            mouse = new THREE.Vector2();
            line_group = new THREE.Group();
            mesh_group = new THREE.Group();

            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousemove', onDocumentMouseMove, false);

            gui = new dat.GUI();
            gui.add(params, 'resolution', 0.01, 1.0).onFinishChange((val) => {
                scene.remove(line_group);
                scene.remove(mesh_group);
                line_group = new THREE.Group();
                mesh_group = new THREE.Group();
                load_odr_data('./data.xodr', params.resolution, params.wireframe);
            });
            gui.add(params, 'wireframe').onChange((val) => {
                for (let mesh of mesh_group.children) {
                    mesh.material.wireframe = params.wireframe;
                    mesh.material.needsUpdate = true;
                }
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onDocumentMouseMove(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        }

        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }

        function update() {
            raycaster.setFromCamera(mouse, camera);
            const intersections = raycaster.intersectObjects(mesh_group.children);
            if (intersections.length > 0) {
                const intersec_pt = intersections[0].point;
                probe_point.position.set(intersec_pt.x, intersec_pt.y, intersec_pt.z);

                let nearest_odr_geom = null;
                let nearest_ref_line_pt = null;
                let nearest_s = null;

                let nearest_dist = -1.0;
                let nearest_odr_geoms = get_nearest_odr_geoms(intersec_pt.x, intersec_pt.y, 3);
                for (let near_odr_geom of nearest_odr_geoms) {
                    const s_proj = near_odr_geom.project(intersec_pt.x, intersec_pt.y);
                    const near_odr_road = OpenDriveMap.roads.get(odr_geom_to_odr_road_id.get(near_odr_geom));
                    const ref_line_pt = near_odr_road.get_refline_point(s_proj, 0.0);
                    const new_dist = Math.sqrt(Math.pow(intersec_pt.x - ref_line_pt[0], 2) + Math.pow(intersec_pt.y - ref_line_pt[1], 2));
                    if (new_dist < nearest_dist || nearest_dist < 0) {
                        nearest_dist = new_dist;
                        nearest_odr_geom = near_odr_geom;
                        nearest_ref_line_pt = ref_line_pt;
                        nearest_s = s_proj;
                    }
                }

                const nearest_odr_road = OpenDriveMap.roads.get(odr_geom_to_odr_road_id.get(nearest_odr_geom));
                const grad_vec = nearest_odr_geom.get_grad(nearest_s);
                const side = Math.sign(grad_vec[0] * (intersec_pt.y - nearest_ref_line_pt[1]) - grad_vec[1] * (intersec_pt.x - nearest_ref_line_pt[0]));
                const t_offs = side * nearest_dist;
                const probe_point_reconstructed = nearest_odr_road.get_refline_point(nearest_s, t_offs);

                probe_line.geometry.attributes.position.array.set([
                    nearest_ref_line_pt[0], nearest_ref_line_pt[1], intersec_pt.z,
                    probe_point_reconstructed[0], probe_point_reconstructed[1], intersec_pt.z]);
                probe_line.geometry.attributes.position.needsUpdate = true;
                probe_line.geometry.computeBoundingSphere();
            }
        }
    </script>
</body>

</html>