<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        table {
            border-spacing: 0.5em 0;
        }

        #bottom_info {
            position: absolute;
            bottom: 0;
            text-align: left;
            font-family: monospace;
            display: block;
            color: white;
        }
    </style>
</head>

<body>
    <div id="bottom_info"></div>
    <input id="xodr_file_input" type="file" style="visibility:hidden"
        onchange="on_file_load(this.files[0].name, true)" />

    <script src="./src/libOpenDrive.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"></script>
    <script src="https://unpkg.com/earcut@2.2.2/dist/earcut.min.js"></script>

    <script>
        var xodr_file = './data.xodr';
        var bottom_info = document.getElementById('bottom_info');

        var params = {
            load_file: () => { document.getElementById('xodr_file_input').click(); },
            resolution: 0.4,
            refline: true,
            refline_offs: false,
            fitView: fitView,
        };

        var colors = {
            lane: 0x72deff,
            outline: 0xffffff,
            refline: 0xff7400,
            refline_offs: 0x00ff00,
            probe_line: 0xff0000,
        };

        var scene = new THREE.Scene();
        var renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 100000);
        camera.position.set(0, 0, 100);
        camera.lookAt(0, 0, 0);
        camera.up.set(0, 0, 1); /* Coordinate system with Z pointing up */
        var controls = new THREE.MapControls(camera, renderer.domElement);

        var mesh_group = new THREE.Group();
        scene.add(mesh_group);
        var line_group = new THREE.Group();
        scene.add(line_group);
        var refline_group = new THREE.Group();
        scene.add(refline_group);
        var refline_offs_group = new THREE.Group();
        scene.add(refline_offs_group);
        var disposable_objs = []

        var probe_line = new THREE.Line(new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(new Float32Array(2 * 3), 3)), new THREE.MeshBasicMaterial({ color: colors.probe_line }));
        scene.add(probe_line);

        var mouse = new THREE.Vector2(), INTERSECTED;
        var raycaster = new THREE.Raycaster();
        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('mousemove', onDocumentMouseMove, false);

        animate();

        var gui = new dat.GUI();
        gui.add(params, 'load_file').name('Load xodr file');
        gui.add(params, 'resolution', 0.01, 1.0).name("Resolution").onFinishChange((val) => {
            load_odr_map(params, true)
        });
        gui.add(params, 'fitView').name("Reset Camera");
        var gui_show_folder = gui.addFolder('Show');
        gui_show_folder.add(params, 'refline').name("RefLine").onChange((val) => {
            refline_group.visible = val;
        });
        gui_show_folder.add(params, 'refline_offs').name("Lane Offset").onChange((val) => {
            refline_offs_group.visible = val;
        });

        var ModuleOpenDrive = null;
        var OpenDriveMap = null;
        libOpenDrive().then(Module => {
            ModuleOpenDrive = Module;
            on_file_load(xodr_file, false);
        });

        function on_file_load(xodr_file, clear_map) {
            fetch(xodr_file).then((file_data) => {
                file_data.text().then((file_text) => {
                    if (clear_map)
                        ModuleOpenDrive['FS_unlink']('./data.xodr');
                    ModuleOpenDrive['FS_createDataFile'](".", "data.xodr", file_text, true, true);
                    OpenDriveMap = new ModuleOpenDrive.OpenDriveMap("./data.xodr");
                    load_odr_map(params, clear_map);
                })
            });
        }

        function load_odr_map(params, clear_map) {
            if (clear_map) {
                mesh_group.remove(...mesh_group.children);
                line_group.remove(...line_group.children);
                refline_group.remove(...refline_group.children);
                for (let obj of disposable_objs)
                    obj.dispose();
            }
            for (const [road_id, road] of stdmapVals(OpenDriveMap.roads)) {
                const lane_secs = stdmapVals(road.lane_sections);

                let road_group = new THREE.Group();
                for (let idx = 0; idx < lane_secs.length; idx++) {
                    /* create lane polygons - presumes lane_section lanes are sorted on lane index */
                    let lanes_outer_border_pts = []; // 2d array
                    let lanes = [];
                    const lane_sec_len = (idx == lane_secs.length - 1) ? road.length - (lane_secs[idx][1]).s0 : (lane_secs[idx + 1][1]).s0 - (lane_secs[idx][1]).s0;
                    const lane_sec = lane_secs[idx][1];
                    for (const [lane_id, lane] of stdmapVals(lane_sec.lanes)) {
                        let s_vals = [];
                        for (let s = lane_sec.s0; s < (lane_sec.s0 + lane_sec_len); s += params.resolution)
                            s_vals.push(s);
                        s_vals.push(lane_sec.s0 + lane_sec_len);
                        lanes_outer_border_pts.push(rdp(s_vals.map(s => lane.get_outer_border_pt(s)), params.resolution));
                        if (lane_id != 0)
                            lanes.push(lane);
                    }

                    /* first get outer edge of all lanes to */
                    for (let idx = 1; idx < lanes_outer_border_pts.length; idx++) {
                        let lane_polygon_pts = lanes_outer_border_pts[idx - 1];
                        lane_polygon_pts.reverse();
                        lane_polygon_pts.push(...lanes_outer_border_pts[idx]);
                        lane_polygon_pts.push(lane_polygon_pts[0]);

                        const lane_geom = new THREE.BufferGeometry().setFromPoints(lane_polygon_pts.map(p => new THREE.Vector3(...p)));
                        const lane_material = new THREE.MeshBasicMaterial({ color: colors.lane, transparent: true, opacity: 0.3 });
                        lane_geom.setIndex(earcut(lane_polygon_pts.flat(), null, 3));
                        let lane_polygon_mesh = new THREE.Mesh(lane_geom, lane_material);
                        lane_polygon_mesh.visible = false;
                        lane_polygon_mesh.userData = { road: road, lane: lanes[idx - 1], mesh_group: road_group };
                        road_group.add(lane_polygon_mesh);

                        const lane_outline_geom = new THREE.BufferGeometry().setFromPoints(lane_polygon_pts.map(p => new THREE.Vector3(...p)));
                        const lane_outline_material = new THREE.LineBasicMaterial({ color: colors.outline, transparent: true, opacity: 0.3 });
                        const lane_outline_line = new THREE.Line(lane_outline_geom, lane_outline_material);
                        line_group.add(lane_outline_line);

                        disposable_objs.push(lane_geom, lane_material, lane_outline_geom, lane_outline_material)
                    }
                }
                mesh_group.add(road_group);

                let s_vals = [];
                for (let s = 0; s < road.length; s += params.resolution)
                    s_vals.push(s);
                s_vals.push(road.length);
                for (const with_offset of [true, false]) {
                    const refl_pts = rdp(s_vals.map(s => road.ref_line.get_point(s, 0.0, 0.0)), params.resolution);
                    const refline_geom = new THREE.BufferGeometry().setFromPoints(refl_pts.map(p => new THREE.Vector3(...p)));
                    const refline_material = new THREE.LineBasicMaterial({ color: with_offset ? colors.refline_offs : colors.refline });
                    const refline_line = new THREE.Line(refline_geom, refline_material);
                    if (with_offset)
                        refline_offs_group.add(refline_line);
                    else
                        refline_group.add(refline_line);
                    disposable_objs.push(refline_geom, refline_material);
                }
                refline_group.visible = params.refline;
                refline_offs_group.visible = params.refline_offs;
            }
            fitView();
        }

        function fitView() {
            const bbox = new THREE.Box3().setFromObject(line_group);
            let center_pt = new THREE.Vector3();
            bbox.getCenter(center_pt);

            const l2xy = 0.5 * Math.sqrt(Math.pow(bbox.max.x - bbox.min.x, 2.0) + Math.pow(bbox.max.y - bbox.min.y, 2));
            const fov2r = (camera.fov * 0.5) * (Math.PI / 180.0);
            const dz = l2xy / Math.tan(fov2r);

            camera.position.set(center_pt.x, center_pt.y, bbox.max.z + dz);
            controls.target.set(center_pt.x, center_pt.y, center_pt.z);
            controls.update();
        }

        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }

        function update() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(mesh_group.children, true);
            if (intersects.length > 0) {
                if (INTERSECTED != intersects[0].object) {
                    if (INTERSECTED) {
                        INTERSECTED.material.opacity = 0.3;
                        INTERSECTED.userData.mesh_group.children.forEach(m => m.visible = false);
                    }
                    INTERSECTED = intersects[0].object;
                    INTERSECTED.material.opacity = 0.7;
                    INTERSECTED.userData.mesh_group.children.forEach(m => m.visible = true);
                    bottom_info.style.display = "block";
                }
            } else {
                if (INTERSECTED) {
                    INTERSECTED.material.opacity = 0.3;
                    INTERSECTED.userData.mesh_group.children.forEach(m => m.visible = false);
                }
                INTERSECTED = null;
                bottom_info.style.display = "none";
            }
            if (INTERSECTED) {
                const userData = INTERSECTED.userData;
                const intersec_pt = intersects[0].point;

                /* project interesected point onto reference line */
                const s_proj = userData.road.ref_line.project(intersec_pt.x, intersec_pt.y);
                const refl_pt = userData.road.ref_line.get_point(s_proj, 0.0, 0.0);

                const grad_vec = userData.road.ref_line.get_grad(s_proj);
                const dist = Math.sqrt(Math.pow(intersec_pt.x - refl_pt[0], 2) + Math.pow(intersec_pt.y - refl_pt[1], 2) + Math.pow(intersec_pt.z - refl_pt[2], 2));
                const t_offs = Math.sign(grad_vec[0] * (intersec_pt.y - refl_pt[1]) - grad_vec[1] * (intersec_pt.x - refl_pt[0])) * dist;
                intersec_pt_reconstructed = userData.road.ref_line.get_point(s_proj, t_offs, 0.0);

                probe_line.geometry.attributes.position.array.set([...refl_pt, intersec_pt_reconstructed[0], intersec_pt_reconstructed[1], intersec_pt.z]);
                probe_line.geometry.attributes.position.needsUpdate = true;
                probe_line.geometry.computeBoundingSphere();

                bottom_info.innerHTML = `
                        <table>
                            <tr><th>road id</th><th>${userData.road.id}</th></tr>
                            <tr><th>section s0</th><th>${userData.lane.lane_section.s0}</th></tr>
                            <tr><th>lane id</th><th>${userData.lane.id}</th></tr>
                            <tr><th>type</th><th>${userData.lane.type}</th></tr>
                            <tr><th>s/t</th><th>[${s_proj.toFixed(2)}, ${t_offs.toFixed(2)}]</th>
                            <tr><th>world</th><th>[${intersec_pt.x.toFixed(2)}, ${intersec_pt.y.toFixed(2)}, ${intersec_pt.z.toFixed(2)}]</th></tr>
                        </table>`;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onDocumentMouseMove(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        }

        function stdmapVals(std_map) {
            let values = [];
            for (let idx = 0; idx < std_map.keys().size(); idx++)
                values.push([std_map.keys().get(idx), std_map.get(std_map.keys().get(idx))]);
            return values;
        }

        function rdp(points, eps) {
            const last = points.length - 1;
            const p1 = points[0];
            const p2 = points[last];
            const x21 = p2[0] - p1[0];
            const y21 = p2[1] - p1[1];

            const [dMax, x] = points.slice(1, last)
                .map(p => Math.abs(y21 * p[0] - x21 * p[1] + p2[0] * p1[1] - p2[1] * p1[0]))
                .reduce((p, c, i) => {
                    const v = Math.max(p[0], c);
                    return [v, v === p[0] ? p[1] : i + 1];
                }, [-1, 0]);

            if (dMax > eps) {
                return [...rdp(points.slice(0, x + 1), eps), ...rdp(points.slice(x), eps).slice(1)];
            }
            return [points[0], points[last]]
        };
    </script>
</body>

</html>