<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <style>
            body { 
                margin: 0;
            }
            canvas { 
                width: 100%;
                height: 100%;
            }
            #tooltip {
                position: fixed;
                text-align: center;
                font-family: monospace;
                background: #a0c020;
                display: block;
            }
        </style>
    </head>
    <body>
        <div id="tooltip"></div>
        <script type="module">
            import * as THREE from "https://cdn.jsdelivr.net/npm/three@v0.108.0/build/three.module.js";
            import { MapControls } from "https://cdn.jsdelivr.net/npm/three@v0.108.0/examples/jsm/controls/OrbitControls.js";

            var camera, controls, scene, renderer;
            var line_group, points_group;
            var raycaster, intersections;
            var mouse, intersected_obj;
            var tooltip;
            
            init();
            animate();

            var odr_data;
            fetch("/data.json").then( res => {
                res.json().then( data => {
                    add_odr_data(data);
                })
            });

            function add_odr_data( odr_data ) {
                for( const feature of odr_data.features ) {
                    const rand_color = Math.random() * 0xffffff;

                    /* lines */
                    var geometry_line = new THREE.Geometry();
                    for( const pt of feature.geometry.coordinates ) {
                        geometry_line.vertices.push(new THREE.Vector3( pt[0], pt[1], 0) );
                    }
                    const material_line = new THREE.LineBasicMaterial( {
                        linewidth: 1,
                        color: rand_color
                    });
                    const line = new THREE.Line( geometry_line, material_line );
                    line.odr_id = feature.properties.id;
                    line_group.add(line);

                    /* line-points */
                    var geometry_points = new THREE.Geometry();
                    for( const pt of feature.geometry.coordinates ) {
                        geometry_points.vertices.push(new THREE.Vector3( pt[0], pt[1], 0 ));
                    }
                    const material_points = new THREE.PointsMaterial( {
                        size: 5,
                        color: rand_color,
                        sizeAttenuation: false } );
                    const points = new THREE.Points( geometry_points, material_points );
                    points_group.add( points );
                }
                scene.add( line_group );
                scene.add( points_group );
            }

            function init() {
                scene = new THREE.Scene();
                renderer = new THREE.WebGLRenderer();
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );
                camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set( 0, 0, 100 );
                camera.lookAt( 0, 0, 0 );
                camera.up.set( 0, 0, 1 ); /* Coordinate system with Z pointing up */
                controls = new MapControls( camera, renderer.domElement );

                var helper = new THREE.GridHelper( 500, 50, 0x0000ff, 0xffffff );
                helper.geometry.rotateX( Math.PI / 2 );
                helper.position.y = 0;
                helper.material.opacity = 0.25;
                helper.material.transparent = true;
                scene.add( helper );

                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
                line_group = new THREE.Group();
                points_group = new THREE.Group();
             
                tooltip = document.getElementById("tooltip");
                window.addEventListener( 'resize', onWindowResize, false );
                window.addEventListener( 'mousemove', onDocumentMouseMove, false );
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }

            function onDocumentMouseMove( event ) {
                event.preventDefault();
                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
            }

            function animate() {
                requestAnimationFrame( animate );
                update();
                renderer.render( scene, camera );
            }

            function update() {
                raycaster.setFromCamera( mouse, camera );
                intersections = raycaster.intersectObjects( line_group.children );
                if ( intersections.length == 0 ) {
                    tooltip.style.display = "none";
                } else {
                    tooltip.style.display = "block";
                    tooltip.style.left = `${ ((mouse.x + 1) / 2) * window.innerWidth - tooltip.offsetWidth - 5 }px`;
                    tooltip.style.top = `${ -((mouse.y - 1) / 2) * window.innerHeight - tooltip.offsetHeight - 5 }px`;
                    if ( intersected_obj != intersections[0].object ) {
                        intersected_obj = intersections[0].object;
                        if( !intersected_obj.odr_id ) {
                            tooltip.innerHTML = "n.a";
                        } else {
                            tooltip.innerHTML = `${intersected_obj.odr_id}`;
                        }
                    }
                }
            }
        </script>
    </body>
</html>