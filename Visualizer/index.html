<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <script src="./src/libOpenDrive.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"></script>
    <script>
        var camera, controls, scene, renderer;
        var line_group, probe_point, gui;
        var mouse, raycaster, intersections;

        var odr_data = null;
        var OpenDriveMap = null;
        var ModuleOpenDrive = null;

        var params = {
            resolution: 0.4
        };

        init();
        animate();

        function load_odr_data(xodr_file, resolution) {
            libOpenDrive().then(Module => {
                ModuleOpenDrive = Module;
                fetch(xodr_file).then((res) => {
                    res.text().then((data) => {
                        Module['FS_createDataFile'](".", "data.xodr", data, true, true);
                        OpenDriveMap = new Module.OpenDriveMap("./data.xodr");
                        for (let r_idx = 0; r_idx < OpenDriveMap.roads.keys().size(); r_idx++) {
                            const road_id = OpenDriveMap.roads.keys().get(r_idx);
                            const odr_road = OpenDriveMap.roads.get(road_id);

                            let ref_line_points = [];
                            for (let s = 0.0; s < odr_road.length; s += resolution) {
                                const pt_3d = odr_road.get_refline_point(s, 0.0);
                                ref_line_points.push(new THREE.Vector3(...pt_3d));
                            }
                            const ref_line_geom = new THREE.BufferGeometry().setFromPoints(ref_line_points);
                            const line = new THREE.Line(ref_line_geom, new THREE.LineBasicMaterial({ color: 0x0000ff }));
                            line_group.add(line);

                            let lane_sec_starts = []
                            for (let ls_idx = 0; ls_idx < odr_road.lane_sections.keys().size(); ls_idx++) {
                                lane_sec_starts.push(odr_road.lane_sections.keys().get(ls_idx));
                            }
                            lane_sec_starts.sort((a, b) => a - b);
                            for (let ls_idx = 0; ls_idx < lane_sec_starts.length; ls_idx++) {
                                const odr_lane_sec = odr_road.lane_sections.get(lane_sec_starts[ls_idx]);
                                const lane_sec_length = (ls_idx == (lane_sec_starts.length - 1)) ? odr_road.length - odr_lane_sec.s0 : lane_sec_starts[ls_idx + 1] - odr_lane_sec.s0;
                                for (let l_idx = 0; l_idx < odr_lane_sec.lanes.keys().size(); l_idx++) {
                                    let lane_idx = odr_lane_sec.lanes.keys().get(l_idx);
                                    const odr_lane = odr_lane_sec.lanes.get(lane_idx);
                                    let lane_border_points = [];
                                    for (let s = odr_lane_sec.s0; s < odr_lane_sec.s0 + lane_sec_length; s += resolution) {
                                        const pt_3d = odr_lane.get_outer_border_pt(s);
                                        lane_border_points.push(new THREE.Vector3(...pt_3d));
                                    }
                                    const lane_border_line_geom = new THREE.BufferGeometry().setFromPoints(lane_border_points);
                                    const lb_line = new THREE.Line(lane_border_line_geom, new THREE.LineBasicMaterial({ color: 0xff00ff }));
                                    line_group.add(lb_line);
                                }
                            }
                        }
                        scene.add(line_group);
                    });
                });
            });
        }

        function init() {
            load_odr_data('./RobotCareAachen.xodr.xml', params.resolution);
            scene = new THREE.Scene();
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 100000);
            camera.position.set(0, 0, 100);
            camera.lookAt(0, 0, 0);
            camera.up.set(0, 0, 1); /* Coordinate system with Z pointing up */
            controls = new THREE.MapControls(camera, renderer.domElement);

            let helper = new THREE.GridHelper(500, 50, 0x0000ff, 0xffffff);
            helper.geometry.rotateX(Math.PI / 2);
            helper.position.y = 0;
            helper.material.opacity = 0.25;
            helper.material.transparent = true;
            scene.add(helper);

            let sphere_geom = new THREE.SphereGeometry(0.1, 32, 32);
            let sphere_material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            probe_point = new THREE.Mesh(sphere_geom, sphere_material);
            scene.add(probe_point);

            raycaster = new THREE.Raycaster();
            raycaster.params.Line.threshold = 0.1;
            mouse = new THREE.Vector2();
            line_group = new THREE.Group();

            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousemove', onDocumentMouseMove, false);

            gui = new dat.GUI();
            gui.add(params, 'resolution', 0.01, 1.0).onFinishChange((val) => {
                scene.remove(line_group);
                line_group = new THREE.Group();
                load_odr_data('./RobotCareAachen.xodr.xml', params.resolution);
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onDocumentMouseMove(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        }

        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }

        function update() {
            raycaster.setFromCamera(mouse, camera);
            let t_z0 = raycaster.ray.origin.z / raycaster.ray.direction.z;
            let x_z0 = raycaster.ray.origin.x - t_z0 * raycaster.ray.direction.x;
            let y_z0 = raycaster.ray.origin.y - t_z0 * raycaster.ray.direction.y;
            probe_point.position.set(x_z0, y_z0, 0.0);
        }
    </script>
</body>

</html>