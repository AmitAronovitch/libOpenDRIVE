<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <script src="./src/libOpenDrive.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"></script>
    <script src="https://unpkg.com/earcut@2.2.2/dist/earcut.min.js"></script>
    <script>
        var camera, controls, scene, renderer;
        var line_group, probe_point, gui;
        var mouse, raycaster, intersections;

        var odr_data = null;
        var OpenDriveMap = null;
        var ModuleOpenDrive = null;

        var params = {
            resolution: 0.4
        };

        init();
        animate();

        function get_map_keys(std_map) {
            let keys = [];
            for (let idx = 0; idx < std_map.keys().size(); idx++)
                keys.push(std_map.keys().get(idx));
            return keys;
        }

        function rdp(points, eps) {
            const last = points.length - 1;
            const p1 = points[0];
            const p2 = points[last];
            const x21 = p2[0] - p1[0];
            const y21 = p2[1] - p1[1];

            const [dMax, x] = points.slice(1, last)
                .map(p => Math.abs(y21 * p[0] - x21 * p[1] + p2[0] * p1[1] - p2[1] * p1[0]))
                .reduce((p, c, i) => {
                    const v = Math.max(p[0], c);
                    return [v, v === p[0] ? p[1] : i + 1];
                }, [-1, 0]);

            if (dMax > eps) {
                return [...rdp(points.slice(0, x + 1), eps), ...rdp(points.slice(x), eps).slice(1)];
            }
            return [points[0], points[last]]
        };

        function load_odr_data(xodr_file, resolution) {
            libOpenDrive().then(Module => {
                ModuleOpenDrive = Module;
                fetch(xodr_file).then((res) => {
                    res.text().then((data) => {
                        Module['FS_createDataFile'](".", "data.xodr", data, true, true);
                        OpenDriveMap = new Module.OpenDriveMap("./data.xodr");
                        for (let road_id of get_map_keys(OpenDriveMap.roads)) {
                            const odr_road = OpenDriveMap.roads.get(road_id);

                            let ref_line_points = [];
                            for (let sample_nr = 0; sample_nr < (odr_road.length / resolution); sample_nr++)
                                ref_line_points.push(odr_road.get_refline_point(sample_nr * resolution, 0.0));
                            ref_line_points = rdp(ref_line_points, resolution);
                            const ref_line_geom = new THREE.BufferGeometry().setFromPoints(ref_line_points.map(p => new THREE.Vector3(...p)));
                            const ref_line_line = new THREE.Line(ref_line_geom, new THREE.LineBasicMaterial({ color: 0x0000ff }));
                            line_group.add(ref_line_line);

                            let lane_sec_s0 = get_map_keys(odr_road.lane_sections);
                            lane_sec_s0.sort((a, b) => a - b);
                            for (let ls_idx = 0; ls_idx < lane_sec_s0.length; ls_idx++) {
                                const odr_lane_sec = odr_road.lane_sections.get(lane_sec_s0[ls_idx]);
                                const lane_sec_length = (ls_idx == (lane_sec_s0.length - 1)) ? odr_road.length - odr_lane_sec.s0 : lane_sec_s0[ls_idx + 1] - odr_lane_sec.s0;
                                let lane_idxs = get_map_keys(odr_lane_sec.lanes);

                                let road_polygon_pts = [];
                                for (let is_leftmost_lane of [true, false]) { //relative to ref line direction
                                    const odr_lane = is_leftmost_lane ? odr_lane_sec.lanes.get(Math.max(...lane_idxs)) : odr_lane_sec.lanes.get(Math.min(...lane_idxs));
                                    let lane_outer_border_pts = [];
                                    for (let sample_nr = 0; sample_nr <= (lane_sec_length / resolution); sample_nr++)
                                        lane_outer_border_pts.push(odr_lane.get_outer_border_pt(odr_lane_sec.s0 + sample_nr * resolution));
                                    lane_outer_border_pts = rdp(lane_outer_border_pts, resolution);
                                    if (is_leftmost_lane)
                                        lane_outer_border_pts.reverse();
                                    road_polygon_pts.push(...lane_outer_border_pts);
                                }
                                road_polygon_pts.push(road_polygon_pts[0]);

                                const road_polygon_geom = new THREE.BufferGeometry().setFromPoints(road_polygon_pts.map(p => new THREE.Vector3(...p)));
                                road_polygon_geom.setIndex(earcut(road_polygon_pts.flat(), null, 3));
                                const road_polygon_mesh = new THREE.Mesh(road_polygon_geom, new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true }));
                                scene.add(road_polygon_mesh);
                            }
                        }
                        scene.add(line_group);
                    });
                });
            });
        }

        function init() {
            load_odr_data('./data.xodr', params.resolution);
            scene = new THREE.Scene();
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 100000);
            camera.position.set(0, 0, 100);
            camera.lookAt(0, 0, 0);
            camera.up.set(0, 0, 1); /* Coordinate system with Z pointing up */
            controls = new THREE.MapControls(camera, renderer.domElement);

            let helper = new THREE.GridHelper(500, 50, 0x0000ff, 0xffffff);
            helper.geometry.rotateX(Math.PI / 2);
            helper.position.y = 0;
            helper.material.opacity = 0.25;
            helper.material.transparent = true;
            scene.add(helper);

            let sphere_geom = new THREE.SphereGeometry(0.1, 32, 32);
            let sphere_material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            probe_point = new THREE.Mesh(sphere_geom, sphere_material);
            scene.add(probe_point);

            raycaster = new THREE.Raycaster();
            raycaster.params.Line.threshold = 0.1;
            mouse = new THREE.Vector2();
            line_group = new THREE.Group();

            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousemove', onDocumentMouseMove, false);

            gui = new dat.GUI();
            gui.add(params, 'resolution', 0.01, 1.0).onFinishChange((val) => {
                scene.remove(line_group);
                line_group = new THREE.Group();
                load_odr_data('./data.xodr', params.resolution);
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onDocumentMouseMove(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        }

        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }

        function update() {
            raycaster.setFromCamera(mouse, camera);
            let t_z0 = raycaster.ray.origin.z / raycaster.ray.direction.z;
            let x_z0 = raycaster.ray.origin.x - t_z0 * raycaster.ray.direction.x;
            let y_z0 = raycaster.ray.origin.y - t_z0 * raycaster.ray.direction.y;
            probe_point.position.set(x_z0, y_z0, 0.0);
        }
    </script>
</body>

</html>